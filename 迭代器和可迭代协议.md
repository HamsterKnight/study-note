## 迭代和遍历的区别

**遍历**：有多个数据组成的集合数据结构（map、set、array等其他类数组），需要从该结构中依次取出数据进行某种处理。

**迭代**：按照某种逻辑，依次取出下一个数据进行处理。



## 迭代器和可迭代协议

**迭代器**：如果一个对象具有**next方法**，且该方法返回一个对象，对象至少包含以下两个属性

```js
{value: 下一个数据的值，done: 是否已经迭代完成}
```

不断调用next的过程，叫做迭代

**迭代器创建函数**：一个返回迭代器的函数

### 可迭代协议

ES6中出现了for-of循环，该循环就是用于迭代某个对象的，因此，for-of循环要求对象必须是可迭代的（对象必须满足可迭代协议）

可迭代协议是用于约束一个对象的，如果一个对象满足下面的规范，则该**对象满足可迭代协议，也称之为该对象是可以被迭代的**。

可迭代协议的约束如下：

1. 对象必须有一个知名符号属性（Symbol.iterator）

2. 该属性必须是一个无参的迭代器创建函数

   

**for...of的原理**

```js
// 模拟for of 循环
const  obj = {
  n: 10,
  [Symbol.iterator]: function () {
    let that = this, i = 0
    return {
      next:function () {
        return {
          value: i++,
          done: that.n < i
        }
      }
    }
  }
}
const iterator = obj[Symbol.iterator]()
let result = iterator.next()

while (!result.done) {
    const item = result.value
    result = iterator.next()
}

```

1. 首先执行Symbol.iterator迭代器创建函数，获取迭代器
2. 执行迭代器的next，得到的第一次结果
3. 获取第一次迭代的结果的value值，赋值给变量，判断当前是否已经迭代结束
4. 如果没有迭代结束，那么进行下一次的迭代，将结果赋值给变量





### 生成器

## generator

生成器：由构造函数Generator创建的对象，该对象既是一个迭代器，同时，又是一个可迭代对象（满足可迭代协议的对象）

```
//伪代码

var generator = new Generator();
generator.next();//它具有next方法
var iterator = generator[Symbol.iterator];//它也是一个可迭代对象
for(const item of generator){
    //由于它是一个可迭代对象，因此也可以使用for of循环
}
```

**注意：Generator构造函数，不提供给开发者使用，仅作为JS引擎内部使用**

## generator function

生成器函数（生成器创建函数）：该函数用于创建一个生成器。

ES6新增了一个特殊的函数，叫做生成器函数，只要在函数名与function关键字之间加上一个*号，则该函数会自动返回一个生成器

生成器函数的特点：

1. 调用生成器函数，会返回一个生成器，而不是执行函数体（因为，生成器函数的函数体执行，收到生成器控制）

2. 每当调用了生成器的next方法，生成器的函数体会从上一次yield的位置（或开始位置）运行到下一个yield

   1. yield关键字只能在生成器内部使用，不可以在普通函数内部使用

   2. 它表示暂停，并返回一个当前迭代的数据

   3. 如果没有下一个yield，到了函数结束，则生成器的next方法得到的结果中的done为true

      ```js
      执行generator.next()
      会执行到const result = yield 1   只会执行yield 1 这句，赋值操作会下次执行next的时候才会走
      ```

      

3. yield关键字后面的表达式返回的数据，会作为当前迭代的数据

   ```
   即会当做当前value的值
   ```

   

4. 生成器函数的返回值，会作为迭代结束时的value

   1. 但是，如果在结束过后，仍然反复调用next，则value为undefined

5. 生成器调用next的时候，可以传递参数，该参数会作为生成器函数体上一次yield表达式的值。

   1. 生成器第一次调用next函数时，传递参数没有任何意义(因为第一次调用，没有上一个yield)

6. 生成器带有一个throw方法，该方法与next的效果相同，唯一的区别在于：

   1. next方法传递的参数会被返回成一个正常值
   2. throw方法传递的参数是一个错误对象，会导致生成器函数内部发生一个错误。(错误发生在yield指令执行的地方)

7. 生成器带有一个return方法，该方法会直接结束生成器函数

8. 若需要在生成器内部调用其他生成器，注意：如果直接调用，得到的是一个生成器，如果加入*号调用，则进入其生成器内部执行。如果是`yield 函数()`调用生成器函数，则该函数的返回结果，为该表达式的结果

