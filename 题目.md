1. 通过迭代器，来实现一个无限的斐波那契数列

```js
var obj = {
    a: 1,
    b: 1,
    next() {
        const c = this.a + this.b
        this.a = this.b
        this.b = c 
        
        const result =  {
            value: c,
            done: false
        }
        return result 
    } 
}
```



2. for, for ... in, for ...of 之间的区别（迭代器相关）

```js
for普通循环

for....in: 遍历对象的可枚举属性（包括原型链上的）

for...of: 对象是可迭代的, 将每次迭代的结果的返回值的value赋值给指定变量
```



3. 找出几个数组中的交集（可用set实现）

   ```js
   var arr1 = [1,3,5,7],
       arr2 = [1,5,6,7,8,9],
       arr3 = [1,4,5,6,7,8,0]
   
   var arrSet1 = new Set(arr1),
   arrSet2 = new Set(arr2),
   arrSet3 = new Set(arr3)
   
   var result = [...arrSet1].filter(_ => arrSet2.has(_) && arrSet3.has(_))
   
   
   ```

   

4. 跨域的解方案

   **【什么叫跨域】？**

   由于浏览器的同源策略，为了防范跨站脚本的攻击，禁止客户端脚本对不同域下的文档或脚本进行跨站调用资源。

   

   **【同源策略】**协议 + 域名 + 端口号一致

   缺少同源策略，浏览器很容易受到`XSS`、`CSFR`等攻击

   

   下面介绍一下这两种攻击：

   **XSS攻击**：Cross Site Scripting 跨站脚本攻击

   - **存储型XSS**

   1. 恶意用户提交了恶意内容到服务器
   2. 服务器没有识别，保存了恶意内容到数据库
   3. 正常用户访问服务器
   4. 服务器在不知情的情况下，给予了之前的恶意内容，让正常用户遭到攻击

   - **反射型**

   1. 恶意用户分享了一个正常网站的链接，链接中带有恶意内容
   2. 正常用户点击了该链接
   3. 服务器在不知情的情况，把链接的恶意内容读取了出来，放进了页面中，让正常用户遭到攻击

   - **dom型**

   1. 恶意用户通过任何方式，向服务器中注入了一些dom元素，从而影响了服务器的dom结构

   2. 普通用户访问时，运行的是服务器的正常js代码

      

   **CSFR**攻击：跨站请求伪造

   本质是：恶意网站把**正常用户**作为**媒介**，通过模拟正常用户的操作，攻击其**登录过**的站点。

   

   【referer和origin】

   		- **referer**代表请求源地址，即是请求是从哪个地址发出的，包含地址的所有内容(路径和参数等)
   		- **origin**仅代表域名或者主机的ip

   

   **下面介绍解决跨域的方案**

   1. **jsonp**

      本质上是利用script标签天然可跨域的特性，服务端注入数据到约定的函数中

      缺点：仅能发出get请求，前后端得确定函数名称

   2. **CORS**跨域资源访问

      需要服务端设置响应头允许跨域**Access-Control-Allow-Origin： ***

   3. **nginx**反向代理

   4. **websocket**
      原因，本身不存在跨域问题，可以用于跨域通信

   5. **window.postMessage**

      提供了一种受控机制来规避此同源限制，只要正确的使用，该方法就很安全

   6. **document.domain + iframe**

      该方式只能用于二级域名相同的情况下

      比如`a.test.com`和`b.test.com`，这两个页面都需要设置`document.domain = 'text.com'`

      然后iframe就可以与主页面进行通信了

   7. **window.location.hash + Iframe**

      原理就是通过 url 带 hash ，通过一个非跨域的中间页面来传递数据。

   8. **window.name + iframe**

      window 对象的 name 属性是一个很特别的属性，当该 window 的 location 变化，然后重新加载，它的 name 属性可以依然保持不变。

      **示例代码**

      其中 a.html 和 b.html 是同域的，都是`http://localhost:8000`，而 c.html 是`http://localhost:8080`

      ```html
      // a.html
      <iframe
        src="http://localhost:8080/name/c.html"
        frameborder="0"
        onload="load()"
        id="iframe"
      ></iframe>
      <script>
        let first = true;
        // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name
        function load() {
          if (first) {
            // 第1次onload(跨域页)成功后，切换到同域代理页面
            iframe.src = "http://localhost:8000/name/b.html";
            first = false;
          } else {
            // 第2次onload(同域b.html页)成功后，读取同域window.name中数据
            console.log(iframe.contentWindow.name);
          }
        }
      </script>
      复制代码
      ```

      b.html 为中间代理页，与 a.html 同域，内容为空。

      ```html
      // b.html
      <div></div>
      复制代码
      // c.html
      <script>
        window.name = "传递的数据";
      </script>
      复制代码
      ```

      通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。

